 user_id | product_id | score
---------+------------+-------
 U001    | A001       |   4.0
 U001    | A002       |   5.0
 U001    | A003       |   5.0
 U002    | A001       |   3.0
 U002    | A002       |   3.0
 U002    | A003       |   4.0
 U003    | A001       |   5.0
 U003    | A002       |   4.0
 U003    | A003       |   4.0
(9 行)

# ユーザーごとの特徴を捉える
SELECT
	user_id,
	MAX(score)
FROM review
GROUP BY user_id;

 user_id | max
---------+-----
 U001    | 5.0
 U002    | 4.0
 U003    | 5.0
(3 行)

# ウィンドウ関数の復習をする
shop=# SELECT * FROM SalesIcecream;
 shop_id | sale_date  | sales_amt
---------+------------+-----------
 A       | 2024-06-01 |     67800
 A       | 2024-06-02 |     87000
 A       | 2024-06-05 |     11300
 A       | 2024-06-10 |      9800
 A       | 2024-06-15 |      9800
 B       | 2024-06-02 |    178000
 B       | 2024-06-15 |     18800
 B       | 2024-06-17 |     19850
 B       | 2024-06-20 |     23800
 B       | 2024-06-21 |     18800
 C       | 2024-06-01 |     12500
(11 行)

# なぜこうなってしまう？
順序指定がないため、通常の集約関数と同じになってしまう
shop=# SELECT
shop-#  SUM(sales_amt) OVER() AS "累計売上"
shop-# FROM SalesIcecream;
 累計売上
----------
   457450
   457450
   457450
   457450
   457450
   457450
   457450
   457450
   457450
   457450
   457450
(11 行)

# これと同じ
shop-#  SUM(sales_amt) AS "累計売上"
shop-# FROM SalesIcecream;
 累計売上
----------
   457450
(1 行)

# 計算の順序付けをする
（ただし、同じ日付の値がまとめられているので注意）
SELECT
	SUM(sales_amt) OVER(ORDER BY sale_date) AS "累計売上"
FROM SalesIcecream;

 累計売上
----------
    80300
    80300
   345300
   345300
   356600
   366400
   395000
   395000
   414850
   438650
   457450
(11 行)

# こうすると行ごとになる
SELECT
	SUM(sales_amt) OVER(ORDER BY sale_date, shop_id) AS "累計売上"
FROM SalesIcecream;

 累計売上
----------
    67800
    80300
   167300
   345300
   356600
   366400
   376200
   395000
   414850
   438650
   457450
(11 行)

# 店舗毎にパーティション化
SELECT
	shop_id,
	SUM(sales_amt) OVER(
		PARTITION BY shop_id
		ORDER BY sale_date, shop_id
	) AS "累計売上"
FROM SalesIcecream;

 shop_id | 累計売上
---------+----------
 A       |    67800
 A       |   154800
 A       |   166100
 A       |   175900
 A       |   185700
 B       |   178000
 B       |   196800
 B       |   216650
 B       |   240450
 B       |   259250
 C       |    12500
(11 行)

# 2日前からの移動平均を求める
SELECT
	shop_id,
	sale_date,
	sales_amt,
	ROUND(
		AVG(sales_amt) OVER(
			PARTITION BY shop_id
			ORDER BY sale_date
			ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
		), 0
	) AS mvg_avg
FROM SalesIcecream;

 shop_id | sale_date  | sales_amt | mvg_avg
---------+------------+-----------+---------
 A       | 2024-06-01 |     67800 |   67800
 A       | 2024-06-02 |     87000 |   77400
 A       | 2024-06-05 |     11300 |   55367
 A       | 2024-06-10 |      9800 |   36033
 A       | 2024-06-15 |      9800 |   10300
 B       | 2024-06-02 |    178000 |  178000
 B       | 2024-06-15 |     18800 |   98400
 B       | 2024-06-17 |     19850 |   72217
 B       | 2024-06-20 |     23800 |   20817
 B       | 2024-06-21 |     18800 |   20817
 C       | 2024-06-01 |     12500 |   12500
(11 行)

# 平均との差分を求めたいがどうする
 student_id | weight
------------+--------
 A          |     55
 B          |     70
 C          |     65
 D          |    120
 E          |     83
 F          |     63
(6 行)

# まずは新しい列を作る（全ての行に対して計算処理をする特徴を使う）
 student_id | weight |         avg
------------+--------+---------------------
 A          |     55 | 76.0000000000000000
 B          |     70 | 76.0000000000000000
 C          |     65 | 76.0000000000000000
 D          |    120 | 76.0000000000000000
 E          |     83 | 76.0000000000000000
 F          |     63 | 76.0000000000000000
(6 行)

# あとはサブクエリで組み込む
SELECT
	student_id,
	weight,
	avg,
	weight - avg AS weight_diff
FROM(
		SELECT
			student_id,
			weight,
			AVG(weight) OVER()
		FROM weights
)t;

 student_id | weight |         avg         |     weight_diff
------------+--------+---------------------+----------------------
 A          |     55 | 76.0000000000000000 | -21.0000000000000000
 B          |     70 | 76.0000000000000000 |  -6.0000000000000000
 C          |     65 | 76.0000000000000000 | -11.0000000000000000
 D          |    120 | 76.0000000000000000 |  44.0000000000000000
 E          |     83 | 76.0000000000000000 |   7.0000000000000000
 F          |     63 | 76.0000000000000000 | -13.0000000000000000
(6 行)

# 丸めてもいいかも
 student_id | weight | round | weight_diff
------------+--------+-------+-------------
 A          |     55 |    76 |         -21
 B          |     70 |    76 |          -6
 C          |     65 |    76 |         -11
 D          |    120 |    76 |          44
 E          |     83 |    76 |           7
 F          |     63 |    76 |         -13
(6 行)
CASE式は行全体に対するラベルの貼り換えで、ウィンドウ関数は行全体に対する計算処理のイメージ

# 最小の枝番を取る
 customer_id | seq | price
-------------+-----+-------
 A           |   1 |   500
 A           |   2 |  1000
 A           |   3 |   700
 B           |   5 |   100
 B           |   6 |  5000
 B           |   7 |   300
 B           |   9 |   200
 B           |  12 |  1000
 C           |  10 |   600
 C           |  20 |   100
 C           |  45 |   200
 C           |  70 |    50
 D           |   3 |  2000
(13 行)

# これがまずは基本
（でもpriceを取ることができない）
 customer_id | min_seq
-------------+---------
 B           |       5
 C           |      10
 D           |       3
 A           |       1
(4 行)

# これでテーブルを作っちゃう
SELECT
	*
FROM(
	SELECT
		customer_id,
		seq,
		price,
		MIN(seq) OVER(
			PARTITION BY customer_id
		)
	FROM Receipts AS min_seq
)t;

# 一度、最初の値を求める計算処理をする
SELECT
	*
FROM(
	SELECT
		customer_id,
		seq,
		price,
		MIN(seq) OVER(
			PARTITION BY customer_id
		) AS min_seq
	FROM Receipts
)t
WHERE seq = min_seq;

 customer_id | seq | price | min_seq
-------------+-----+-------+---------
 A           |   1 |   500 |       1
 B           |   5 |   100 |       5
 C           |  10 |   600 |      10
 D           |   3 |  2000 |       3
(4 行)
